<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyphonic MIDI Piano Keyboard with Pitch Practice</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Custom styles for the piano keyboard and practice section */
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #piano-container {
            overflow-x: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #piano-container::-webkit-scrollbar {
            display: none;
        }

        #notes-container {
            display: inline-flex;
            align-items: flex-start;
            padding: 2rem 1rem;
            background-color: #1a202c;
            border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border: 2px solid #4a5568;
        }

        .key {
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            box-sizing: border-box;
            transition: filter 0.1s ease-in-out, opacity 0.2s;
        }
        
        .key.pressed, .key:active {
            filter: brightness(1.3);
        }
        
        .key.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .white-key {
            width: 50px;
            height: 220px;
            border: 1px solid #4a5568;
            border-radius: 0 0 6px 6px;
            box-shadow: inset 0 1px 5px rgba(255, 255, 255, 0.1), 0 5px 8px rgba(0,0,0,0.4);
            padding-bottom: 0.5rem;
        }

        .black-key {
            width: 30px;
            height: 130px;
            border-radius: 0 0 4px 4px;
            z-index: 10;
            margin-left: -15px;
            margin-right: -15px;
            box-shadow: inset 0 -8px 5px rgba(0,0,0,0.5), 0 3px 5px rgba(0,0,0,0.5);
            padding-bottom: 0.5rem;
        }

        .key-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col h-screen">

    <!-- Main container for the app -->
    <div id="app-container" class="hidden flex-col h-full">
        <header class="container mx-auto p-4 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900 dark:text-white">Pitch Matching Practice</h1>
            <p class="text-md text-gray-600 dark:text-gray-400 mt-2">Listen to the secret pitch, find it on the keyboard, then reveal the answer.</p>
        </header>

        <!-- Pitch Practice Controls -->
        <section id="practice-section" class="container mx-auto p-4 bg-gray-200 dark:bg-gray-800 rounded-lg shadow-md mb-4">
            <div class="flex flex-wrap items-center justify-center gap-4">
                <!-- Buttons -->
                <button id="play-secret-pitch-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">Play Secret Pitch</button>
                <button id="reveal-pitch-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">Reveal Secret Pitch</button>
                
                <!-- Dropdowns -->
                <div class="flex items-center gap-2">
                    <label for="secret-instrument-select" class="font-semibold">Secret Pitch Instrument:</label>
                    <select id="secret-instrument-select" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2"></select>
                </div>
                 <div class="flex items-center gap-2">
                    <label for="keys-instrument-select" class="font-semibold">Keyboard Instrument:</label>
                    <select id="keys-instrument-select" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2"></select>
                </div>
            </div>
            <div id="reveal-message" class="text-center mt-4 text-xl font-bold text-blue-500 hidden"></div>
            <div id="loading-message" class="text-center mt-4 text-lg font-semibold text-yellow-500 hidden">Loading Instrument...</div>
        </section>

        <!-- Piano Container -->
        <div id="piano-container" class="w-full flex-grow flex items-center">
            <div id="notes-container">
                <!-- Piano keys will be dynamically generated here -->
            </div>
        </div>
        
        <!-- Settings Button -->
        <div class="text-center p-4">
            <button id="settings-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Settings</button>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-2xl w-full max-w-md">
            <h2 class="text-2xl font-bold mb-6 text-center">Settings</h2>
            <div class="space-y-4">
                <div class="flex items-center justify-between">
                    <label for="min-pitch-select" class="font-semibold">Min Pitch:</label>
                    <select id="min-pitch-select" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 w-1/2"></select>
                </div>
                <div class="flex items-center justify-between">
                    <label for="max-pitch-select" class="font-semibold">Max Pitch:</label>
                    <select id="max-pitch-select" class="bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 w-1/2"></select>
                </div>
            </div>
            <div class="text-center mt-8">
                <button id="close-settings-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Start Screen -->
    <div id="start-screen" class="flex-grow flex items-center justify-center">
        <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105 text-xl">
            Click to Start
        </button>
    </div>

    <script type="module">
        console.log("Script execution started.");
        import { getMidiNoteColor } from 'https://cdn.jsdelivr.net/gh/JotaGreen/keytap@main/midiColorConverter.js';
        console.log("Successfully imported getMidiNoteColor function.");

        // --- DOM Elements ---
        const startButton = document.getElementById('start-button');
        const startScreen = document.getElementById('start-screen');
        const appContainer = document.getElementById('app-container');
        const notesContainer = document.getElementById('notes-container');
        const playSecretPitchBtn = document.getElementById('play-secret-pitch-btn');
        const revealPitchBtn = document.getElementById('reveal-pitch-btn');
        const revealMessage = document.getElementById('reveal-message');
        const loadingMessage = document.getElementById('loading-message');
        const secretInstrumentSelect = document.getElementById('secret-instrument-select');
        const keysInstrumentSelect = document.getElementById('keys-instrument-select');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const minPitchSelect = document.getElementById('min-pitch-select');
        const maxPitchSelect = document.getElementById('max-pitch-select');

        // --- State Variables ---
        let keysInstrument, secretPitchInstrument, activeSecretInstrument;
        let tempRandomInstrument = null; // To hold the randomly chosen instrument
        let currentSecretMidiNote = null;
        let minMidi, maxMidi;

        // --- Instrument Definitions ---
        const instruments = {
            'acoustic_grand_piano': { name: 'Acoustic Grand Piano' },
            'electric_piano_2': { name: 'Electric Piano' },
            'harmonica': { name: 'Harmonica' },
            'acoustic_guitar_nylon': { name: 'Nylon Guitar' },
            'electric_guitar_clean': { name: 'Electric Guitar' },
            'electric_bass_finger': { name: 'Bass Guitar' },
            'violin': { name: 'Violin' },
            'voice_oohs': { name: 'Voice Oohs' },
            'tenor_sax': { name: 'Tenor Sax' },
            'flute': { name: 'Flute' },
            'trumpet': { name: 'Trumpet' },
            'trombone': { name: 'Trombone' }
        };

        // --- Utility Functions ---
        function midiToPitchName(midiNote) {
            const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const octave = Math.floor(midiNote / 12) - 1;
            const noteIndex = midiNote % 12;
            return `${noteNames[noteIndex]}${octave}`;
        }

        function pitchNameToFileName(pitchName) {
            if (pitchName.includes('#')) {
                const note = pitchName.charAt(0);
                const octave = parseInt(pitchName.slice(2));
                const flatMap = { 'C': 'Db', 'D': 'Eb', 'F': 'Gb', 'G': 'Ab', 'A': 'Bb' };
                return `${flatMap[note]}${octave}`;
            }
            return pitchName;
        }

        function setLoading(isLoading) {
            loadingMessage.classList.toggle('hidden', !isLoading);
            playSecretPitchBtn.disabled = isLoading;
            revealPitchBtn.disabled = isLoading;
            document.querySelectorAll('.key').forEach(k => k.classList.toggle('disabled', isLoading));
        }

        // --- Instrument Loading ---
        function loadInstrument(instrumentKey) {
            console.log(`Creating sampler for ${instrumentKey}`);
            const baseUrl = `https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/${instrumentKey}-mp3/`;
            const urls = {};
            for (let i = 24; i <= 108; i++) { // Load samples for the entire possible range
                const pitch = midiToPitchName(i);
                if (pitch.startsWith('C') || pitch.startsWith('F#') || pitch.startsWith('A')) {
                    urls[pitch] = `${pitchNameToFileName(pitch)}.mp3`;
                }
            }
            return new Promise((resolve, reject) => {
                const sampler = new Tone.Sampler({ urls, baseUrl, onload: () => {
                    console.log(`✅ ${instruments[instrumentKey].name} samples loaded.`);
                    resolve(sampler.toDestination());
                }, onerror: (error) => {
                    console.error(`❌ Error loading sampler for ${instrumentKey}:`, error);
                    reject(error);
                }});
            });
        }
        
        async function changeKeysInstrument(instrumentKey) {
            console.log(`--- Changing Keyboard Instrument to: ${instrumentKey} ---`);
            setLoading(true);
            try {
                if (keysInstrument) keysInstrument.dispose();
                keysInstrument = await loadInstrument(instrumentKey);
            } catch (error) { console.error("Failed to change keys instrument:", error); } 
            finally { setLoading(false); }
        }

        async function changeSecretInstrument(instrumentKey) {
            console.log(`--- Changing Secret Pitch Instrument to: ${instrumentKey} ---`);
            if (instrumentKey !== 'random') {
                setLoading(true);
                try {
                    if (secretPitchInstrument) secretPitchInstrument.dispose();
                    secretPitchInstrument = await loadInstrument(instrumentKey);
                    activeSecretInstrument = secretPitchInstrument;
                } catch (error) { console.error("Failed to change secret instrument:", error); }
                 finally { setLoading(false); }
            } else {
                activeSecretInstrument = null; // Will be loaded on new secret note
            }
        }

        // --- App Initialization & Settings ---
        startButton.addEventListener('click', async () => {
            console.log("Start button clicked. Initializing audio and app.");
            try {
                await Tone.start();
                startScreen.classList.add('hidden');
                appContainer.classList.remove('hidden');
                appContainer.classList.add('flex');
                populateInstrumentSelectors();
                populatePitchSelectors();
                await updateSettingsAndKeyboard();
            } catch (error) {
                console.error("Error starting app:", error);
                appContainer.innerHTML = `<div class="text-center text-red-500">Failed to initialize. Please refresh the page.</div>`;
            }
        });
        
        async function updateSettingsAndKeyboard() {
            minMidi = parseInt(minPitchSelect.value);
            maxMidi = parseInt(maxPitchSelect.value);
            console.log(`Updating keyboard range to MIDI ${minMidi}-${maxMidi}`);
            
            generatePianoKeys(minMidi, maxMidi);
            
            // Load instruments if they don't exist
            if (!keysInstrument) await changeKeysInstrument(keysInstrumentSelect.value);
            if (!secretPitchInstrument && secretInstrumentSelect.value !== 'random') {
                 await changeSecretInstrument(secretInstrumentSelect.value);
            }
            
            await setNewSecretNote();
        }
        
        function populateInstrumentSelectors() {
            for (const key in instruments) {
                keysInstrumentSelect.add(new Option(instruments[key].name, key));
                secretInstrumentSelect.add(new Option(instruments[key].name, key));
            }
            secretInstrumentSelect.add(new Option("Random", "random"));
            keysInstrumentSelect.value = 'acoustic_grand_piano';
            secretInstrumentSelect.value = 'acoustic_grand_piano';
        }

        function populatePitchSelectors() {
            for (let i = 24; i <= 108; i++) { // Full range for selectors
                const pitchName = midiToPitchName(i);
                minPitchSelect.add(new Option(pitchName, i));
                maxPitchSelect.add(new Option(pitchName, i));
            }
            minPitchSelect.value = 36; // C2
            maxPitchSelect.value = 84; // C6
        }

        // --- Pitch Practice Logic ---
        async function setNewSecretNote() {
            currentSecretMidiNote = Math.floor(Math.random() * (maxMidi - minMidi + 1)) + minMidi;
            console.log(`New secret note set: ${midiToPitchName(currentSecretMidiNote)}`);
            
            if (secretInstrumentSelect.value === 'random') {
                const instrumentKeys = Object.keys(instruments);
                const randomKey = instrumentKeys[Math.floor(Math.random() * instrumentKeys.length)];
                setLoading(true);
                try {
                    if (tempRandomInstrument) tempRandomInstrument.dispose();
                    tempRandomInstrument = await loadInstrument(randomKey);
                    activeSecretInstrument = tempRandomInstrument;
                } catch (error) { console.error("Failed to load random instrument", error); }
                finally { setLoading(false); }
            } else {
                activeSecretInstrument = secretPitchInstrument;
            }

            revealMessage.classList.add('hidden');
            revealPitchBtn.textContent = 'Reveal Secret Pitch';
        }

        // --- Event Listeners ---
        const playNote = () => {
            if (activeSecretInstrument) {
                activeSecretInstrument.triggerAttack(midiToPitchName(currentSecretMidiNote));
            }
        };
        const stopNote = () => {
            if (activeSecretInstrument) {
                activeSecretInstrument.triggerRelease(midiToPitchName(currentSecretMidiNote));
            }
        };
        
        playSecretPitchBtn.addEventListener('mousedown', playNote);
        playSecretPitchBtn.addEventListener('mouseup', stopNote);
        playSecretPitchBtn.addEventListener('mouseleave', stopNote);
        playSecretPitchBtn.addEventListener('touchstart', (e) => { e.preventDefault(); playNote(); });
        playSecretPitchBtn.addEventListener('touchend', stopNote);

        revealPitchBtn.addEventListener('click', () => {
            if (revealPitchBtn.textContent.includes('Reveal')) {
                revealMessage.textContent = `The note was: ${midiToPitchName(currentSecretMidiNote)}`;
                revealMessage.classList.remove('hidden');
                revealPitchBtn.textContent = 'New Secret Pitch';
            } else {
                setNewSecretNote();
            }
        });
        
        keysInstrumentSelect.addEventListener('change', (e) => changeKeysInstrument(e.target.value));
        secretInstrumentSelect.addEventListener('change', (e) => {
            changeSecretInstrument(e.target.value).then(setNewSecretNote);
        });

        settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));
        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
            updateSettingsAndKeyboard();
        });

        // --- Piano Key Generation ---
        function generatePianoKeys(minKey, maxKey) {
            console.log(`Generating keys from ${minKey} to ${maxKey}`);
            notesContainer.innerHTML = ''; // Clear previous keys
            for (let midi = minKey; midi <= maxKey; midi++) {
                const pitchName = midiToPitchName(midi);
                const isBlackKey = pitchName.includes('#');
                const key = document.createElement('div');
                key.className = 'key ' + (isBlackKey ? 'black-key' : 'white-key');
                
                const [r, g, b] = getMidiNoteColor(midi);
                key.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                
                const label = document.createElement('span');
                label.className = 'key-label';
                label.textContent = pitchName;
                key.appendChild(label);

                const attack = (e) => {
                    e.preventDefault();
                    if (keysInstrument && !key.classList.contains('pressed') && !key.classList.contains('disabled')) {
                        keysInstrument.triggerAttack(pitchName);
                        key.classList.add('pressed');
                    }
                };
                const release = () => {
                    if (keysInstrument && key.classList.contains('pressed')) {
                        keysInstrument.triggerRelease(pitchName);
                        key.classList.remove('pressed');
                    }
                };
                
                key.addEventListener('mousedown', attack);
                key.addEventListener('mouseup', release);
                key.addEventListener('mouseleave', release);
                key.addEventListener('touchstart', attack, { passive: false });
                key.addEventListener('touchend', release);
                key.addEventListener('touchcancel', release);

                notesContainer.appendChild(key);
            }
        }
    </script>

</body>
</html>
